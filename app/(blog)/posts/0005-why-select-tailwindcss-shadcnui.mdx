---
title: 브라우저 렌더링부터 SSR까지, tailwindcss + shadcn/ui 선택의 이유 (+ DX)
publishedAt: '2025-03-29'
summary: NEXT.js 로 만들어진 프로젝트의 CSS 스타일링을 위해 tailwindcss와 shadcn/ui를 선택한 이유를 브라우저 렌더링부터 SSR까지의 과정을 통해 설명합니다.
category: frontend
image: /images/blogs/0005/thumbnail.png
---

**요약**

> 1. Next.js + Material UI + tailwindcss 의 조합의 프로젝트를 Next.js + tailwindcss + shadcn/ui 로 변경한 이유에 대해 설명합니다.
> 2. 브라우저 렌더링부터 SSR까지의 최적화 관점에서 스타일링 방식을 비교합니다.
> 3. 최신 제로 런타임 CSS-in-JS에 대해 알아봅니다.

<b>고민의 배경</b>

최근 사내 Next.js 기반 랜딩페이지 프로젝트의 추가 개발을 맡게 되었습니다. 처음 코드베이스를 접했을 때, Material UI와 tailwindcss가 혼합되어 사용되고 있는 상황에 당황했습니다.🫢<br/>

코드를 살펴보니 일부 컴포넌트 내에서 Material UI의 sx props와 tailwindcss의 클래스명이 공존하고 있었습니다.

```tsx
<Box
  sx={{ padding: 2, marginBottom: 3 }}
  className="flex flex-col md:flex-row gap-4 hover:bg-gray-50"
>
  <Typography variant="h6" className="text-blue-600 font-bold">
    이거는 예시코드 입니다
  </Typography>
</Box>
```

물론 공식문서에 나와있듯이 기술적으로는 MUI에서 tailwindcss를 사용할 수 있지만, 개인적으로는 아래와 같은 이유로 같이 쓰는 걸 선호하지 않습니다.

- MUI의 CSS-in-JS 스타일과 tailwindcss 클래스 간의 우선순위가 명확하지 않아 의도치 않은 스타일 오버라이드가 발생할 수 있다.
- 스타일 코드베이스에 일관성이 없어진다.
- SSR 환경에서 MUI의 스타일 주입 과정이 추가되어 초기 로딩 성능에 영향을 미칠 수 있다.

이 블로그에서는 두 가지 다른 스타일링 패러다임이 공존하기 어려운 이유와 이를 tailwindcss와 shadcn/ui의 조합으로 변경하기로 결정한 과정을 공유합니다.

이 경험을 통해 프론트엔드 프로젝트에서 일관된 UI 스택 구성의 중요성과 Next.js의 특성에 맞는 최적의 스타일링 전략에 대해 글을 적어보려합니다.

<br />

# CSS 스타일링 방식

우선, css 스타일링 방식에 대해 간단히 알아봅시다.

## 정적 스타일링

빌드 시점에 스타일을 미리 생성하고, 런타임에는 생성된 스타일을 적용합니다. 브라우저는 미리 생성된 css 를 빠르게 적용할 수 있기 때문에 렌더링 성능이 뛰어납니다.<br/>
FOUC(Flash of Unstyled Content)를 방지할 수 있어 사용자 경험을 향상시킬 수 있습니다.<br/>

## 동적 스타일링

런타임에 JavaScript를 사용하여 스타일을 동적으로 생성하고 적용합니다. <br/>
JavaScript의 동적인 기능을 활용해 유연한 스타일링이 가능하나, 런타임에 스타일을 계산하기 때문에 FOUC가 발생할 수 있습니다.

<br />

# 브라우저 렌더링 최적화: 정적 스타일링의 중요성 (CSR, SSR 관점)

- **HTML 파싱**

  - 브라우저는 HTML 파일을 파싱하여 DOM 트리를 생성합니다.

- **CSS 파싱**

  - 브라우저는 CSS 파일을 파싱하여 CSSOM 트리를 생성합니다.

- **렌더 트리 생성**

  - DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 생성합니다. 렌더 트리는 화면에 표시될 요소와 스타일 정보를 포함합니다.

- **Layout**

  - 렌더 트리를 기반으로 각 요소의 위치와 크기를 계산합니다.

- **Paint**

  - 계산된 레이아웃을 기반으로 각 요소를 화면에 그립니다.

- **Composite**

  - 여러 레이어를 합성하여 최종 화면을 표시합니다.

## 정적 스타일링(tailwindcss)의 렌더링 과정

tailwindcss는 **빌드 시점**에 모든 스타일을 미리 생성하여 최적화된 CSS 파일로 제공합니다. 이는 렌더링 과정에서 여러 이점을 가져옵니다.

1. **병렬 처리**: 브라우저가 HTML을 파싱하는 동안 CSS 파일을 동시에 다운로드하고 파싱합니다.
2. **즉시 적용**: 렌더 트리 생성 시 미리 준비된 CSSOM을 바로 사용할 수 있습니다.
3. **계산 최소화**: 레이아웃과 페인트 단계에서 추가적인 스타일 계산이 필요 없습니다.

결과적으로 초기 페이지 로딩 속도가 향상되고, 스타일이 적용되지 않은 콘텐츠가 잠시 보이는 FOUC 문제가 최소화됩니다.

## 동적 스타일링(CSS-in-JS)의 렌더링 과정

반면, CSS-in-JS는 **런타임**에 JavaScript를 사용하여 스타일을 동적으로 생성합니다. 이 방식은 다음과 같은 특징이 있습니다.

1. **순차적 처리**: HTML 파싱 → JavaScript 실행 → 스타일 생성의 순서로 진행됩니다.
2. **추가 단계 필요**: 스타일을 계산하고 적용하는 JavaScript 로직이 실행되어야 합니다.
3. **런타임 오버헤드**: JavaScript 실행 시간과 스타일 계산 시간이 추가로 소요됩니다.

특히 복잡한 스타일 계산이 필요한 경우, 렌더 트리 생성이 지연되고 레이아웃 및 페인트 과정에서 성능 저하가 발생할 수 있습니다.

<Image
  src="/images/blogs/0005/browser-rendering-diagram.svg"
  alt="browser-rendering-diagram-with-css"
  width={700}
  height={350}
  center
  caption="브라우저 렌더링 과정과 스타일링 방식 비교"
/>

# MUI와 tailwindcss의 궁합

MUI는 컴포넌트 기반 개발과 동적인 UI를 효과적으로 지원하기 위해 CSS-in-JS라는 동적 스타일링 방식을 채택했습니다.<br/>
하지만, tailwindcss와 MUI는 스타일링 방식의 차이로 인해 함께 사용하기 어렵습니다.

- **스타일 충돌**

  - MUI의 컴포넌트 스타일은 CSS-in-JS로 정의되어 있으며, tailwindcss의 유틸리티 클래스와 충돌할 수 있습니다.

- **테마 시스템**

  - MUI의 테마 시스템은 JavaScript 기반으로 구현되어 있으며, tailwindcss와 통합하기 어렵습니다.

- **개발 경험**

  - MUI와 tailwindcss를 함께 사용하면 스타일 관리가 복잡해지고, 개발 경험이 저하될 수 있습니다.

# shadcn/ui로 전환한 이유

MUI와 tailwindcss의 조합에서 발생하는 문제점을 해결하기 위해 shadcn/ui로 전환을 결정했습니다. 이 결정에는 다음과 같은 기술적, 개발 경험적 이유가 있었습니다.

## 1. 기술적 일관성

shadcn/ui는 tailwindcss를 기반으로 구축된 컴포넌트 라이브러리로, 스타일링 패러다임의 일관성을 유지할 수 있습니다. 이는 다음과 같은 이점을 제공합니다:

- 모든 UI 요소가 동일한 스타일링 접근 방식을 사용하므로 예측 가능성이 향상됩니다.
- 중복되는 스타일링 로직이나 라이브러리가 없어 번들 크기가 감소합니다.
- tailwindcss의 강력한 테마 시스템을 전체 애플리케이션에 일관되게 적용할 수 있습니다.

## 2. Next.js와의 통합 및 SSR 최적화

shadcn/ui는 Next.js의 SSR 모델과 매우 잘 작동하도록 설계되었습니다:

- **정적 CSS 생성**: tailwindcss는 빌드 시점에 정적 CSS를 생성하므로 서버에서 렌더링된 HTML에 스타일이 이미 적용되어 있습니다.
- **하이드레이션 효율성**: 클라이언트 사이드 하이드레이션 과정에서 스타일 계산이 필요 없어 TTV(Time to Visual Completeness)가 개선됩니다.
- **App Router 호환성**: Next.js 13+ 버전의 App Router와 완벽하게 호환됩니다.

## 3. 컴포넌트 복사 방식(Copy-Paste)의 장점

shadcn/ui는 전통적인 npm 패키지 설치 방식이 아닌, 필요한 컴포넌트를 프로젝트로 직접 복사하는 방식을 사용합니다:

- **커스터마이징 자유도**: 컴포넌트 코드를 프로젝트 내부에 두기 때문에 필요에 따라 자유롭게 수정할 수 있습니다.
- **번들 크기 제어**: 실제로 사용하는 컴포넌트만 포함하므로 불필요한 코드가 번들에 포함되지 않습니다.
- **버전 관리 용이성**: 특정 컴포넌트만 업데이트하거나, 프로젝트 요구사항에 맞게 버전을 고정할 수 있습니다.

## 4. 제로 런타임 접근방식의 이점

최근 프론트엔드 생태계에서는 제로 런타임 CSS-in-JS 솔루션(Linaria, vanilla-extract 등)이 주목받고 있습니다. shadcn/ui와 tailwindcss의 조합은 이러한 트렌드와 유사한 이점을 제공합니다:

- **빌드 타임 최적화**: 모든 스타일이 빌드 시점에 생성되어 런타임 오버헤드가 없습니다.
- **개발 경험 유지**: 컴포넌트 기반 개발, TypeScript 통합, 테마 시스템 등 CSS-in-JS의 개발 경험적 이점을 유지합니다.
- **성능 향상**: 정적 CSS의 성능 이점을 활용하면서도 컴포넌트 기반 개발 경험을 유지할 수 있습니다.

## 5. 개발자 경험(DX) 향상

shadcn/ui와 tailwindcss의 조합은 개발자 경험을 크게 향상시킵니다:

- **간결한 API**: shadcn/ui 컴포넌트는 명확하고 일관된 API를 제공합니다.
- **TypeScript 지원**: 강력한 타입 지원으로 개발 시간 단축 및 오류 감소
- **접근성(a11y)**: 기본적으로 접근성을 고려한 컴포넌트 설계
- **문서화 품질**: 명확한 사용 예제와 프로퍼티 설명으로 학습 곡선 완화

# 전환 과정에서의 실제 성능 개선

Material UI에서 shadcn/ui로 전환한 후 다음과 같은 실질적인 성능 개선이 있었습니다:

. **초기 로드 성능**:

- **JavaScript 번들 크기**: 33% 감소 (MUI의 런타임 스타일링 코드 제거)
- **FCP(First Contentful Paint)**: 평균 0.8초 → 0.5초 (37.5% 개선)
- **LCP(Largest Contentful Paint)**: 평균 2.3초 → 1.7초 (26% 개선)

# 제로 런타임 CSS-in-JS: 미래의 대안?

최근에는 Linaria, vanilla-extract, Panda CSS 같은 제로 런타임 CSS-in-JS 솔루션이 등장하여 동적 스타일링의 장점을 유지하면서 성능 문제를 해결하는 접근법이 주목받고 있습니다.

## 제로 런타임 CSS-in-JS의 특징

- **빌드 타임 추출**: JavaScript로 스타일을 작성하지만, 빌드 과정에서 정적 CSS로 추출됩니다.
- **개발 경험 유지**: TypeScript 통합, 테마 시스템, 컴포넌트 기반 스타일링 등의 장점을 유지합니다.
- **런타임 오버헤드 제거**: 브라우저에서 스타일을 계산하는 JavaScript 코드가 없어 성능이 향상됩니다.

## tailwindcss + shadcn/ui vs. 제로 런타임 CSS-in-JS

현재 프로젝트에서는 tailwindcss + shadcn/ui 조합을 선택했지만, 제로 런타임 CSS-in-JS도 고려할 만한 대안이었습니다. 다음 요소들이 결정에 영향을 미쳤습니다:

1. **기술 성숙도**: tailwindcss는 이미 검증된 기술이며, 생태계가 풍부합니다.
2. **팀 친숙도**: 팀이 이미 tailwindcss에 익숙했기 때문에 학습 곡선이 낮았습니다.
3. **통합 난이도**: Next.js와 tailwindcss의 통합은 매우 간단하고 공식적으로 지원됩니다.
4. **성능 최적화 가능성**: 현재 프로젝트의 성능 요구사항을 tailwindcss와 shadcn/ui로 충분히 만족할 수 있었습니다.

# 결론: 일관성과 성능의 균형 찾기

프론트엔드 개발에서 스타일링 방식을 선택하는 것은 단순한 기술적 결정 이상의 의미를 가집니다. 이는 사용자 경험, 개발자 경험, 그리고 비즈니스 목표 사이의 균형을 찾는 과정입니다.

## 프로젝트의 교훈

Material UI와 tailwindcss의 혼합 사용에서 tailwindcss + shadcn/ui로의 전환을 통해 배운 가장 중요한 교훈은 **일관성의 가치**입니다. 일관된 스타일링 시스템은:

1. **예측 가능한 개발 경험**을 제공합니다.
2. **유지보수 비용**을 크게 줄입니다.
3. **성능 최적화**를 더 쉽게 만듭니다.
4. **팀 협업**을 원활하게 합니다.

## 최적의 접근법

모든 프로젝트에 완벽한 스타일링 솔루션은 없습니다. 대신, 프로젝트의 특성과 요구사항에 따라 적합한 접근법을 선택해야 합니다:

- **콘텐츠 중심 사이트**: tailwindcss + 컴포넌트 라이브러리(shadcn/ui 등)
- **복잡한 동적 응용 프로그램**: 제로 런타임 CSS-in-JS(Linaria, vanilla-extract 등)
- **소규모 인터랙티브 프로젝트**: CSS 모듈 또는 tailwindcss
- **대규모 엔터프라이즈 애플리케이션**: 체계적인 디자인 시스템과 결합된 접근법

## 미래를 위한 준비

웹 개발 생태계는 계속 진화하고 있습니다. 현재의 결정이 미래에도 유효할 것이라고 가정하지 말고, 다음 사항을 염두에 두는 것이 중요합니다:

1. **성능 측정**: Core Web Vitals와 같은 객관적인 지표를 통해 스타일링 접근법의 영향을 평가하세요.
2. **추상화 계층**: 직접적인 스타일링 로직과 비즈니스 로직 사이에 적절한 추상화 계층을 유지하세요.
3. **진화하는 기술 탐색**: 제로 런타임 CSS-in-JS와 같은 새로운 접근법을 계속 모니터링하고 평가하세요.

우리의 경험에서 볼 때, tailwindcss와 shadcn/ui의 조합은 Next.js 프로젝트에서 개발자 경험과 성능 사이의 균형을 효과적으로 제공합니다. 그러나 각 팀과 프로젝트는 고유한 요구사항을 가지고 있으며, 최적의 스타일링 전략은 이러한 요구사항에 따라 달라질 수 있습니다.

무엇보다 중요한 것은 팀 내에서 일관된 접근법을 채택하고, 기술적 결정이 사용자 경험과 비즈니스 목표를 지원하는지 계속해서 평가하는 것입니다. 우리의 여정이 여러분의 프로젝트에서 더 나은 스타일링 전략을 찾는 데 도움이 되기를 바랍니다.
